================================================================================
                    UNIDICT CORE ARCHITECTURE DIAGRAM
================================================================================

                              GUI LAYER (Qt)
                          [GUI Components]
                                 |
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                |                |                |
                v                v                v
        [Index GUI]       [Data GUI]      [Manager GUI]
                |                |                |
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 |
                          ADAPTER LAYER (Qt)
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            |                    |                    |
            v                    v                    v
   IndexEngineQt          DataStoreQt         DictionaryManagerQt
            |                    |                    |
    (Bridges to std)      (Bridges to std)   (Bridges to std)
            |                    |                    |
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 |
                      QT WRAPPER LAYER (Core)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        |                       |                       |
        v                       v                       v
  IndexEngine            DataStore              DictionaryManager
  (Qt-facing)            (Qt-facing)            (Qt-facing)
        |                       |                       |
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 |
                    ===== BOUNDARY (Qt â†” Std) =====
                                 |
                        STD CORE LAYER (C++17)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    |                            |                            |
    v                            v                            v
IndexEngineStd              DataStoreStd          DictionaryManagerStd
 (Trie + HashMap)         (JSON persistence)     (Format orchestration)
    |                            |                            |
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 |
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        |            PARSER LAYER (Std Implementations)      |
        |                        |                            |
        v                        v                            v
  JsonParserStd       StarDictParserStd         MdictParserStd
  (102 LOC)          (190 LOC)                  (567 LOC)
        |                        |                    |
        |                        v                    |
        |                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           |
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ DslParserStd â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ (291 LOC)   â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 |
                                 v
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚CsvParserStd â”‚
                          â”‚ (163 LOC)  â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    UTILITY LAYER (Dual Implementation)
        |                    |                    |
        v                    v                    v
  PathUtils (Qt)      PluginManager (Qt)   LookupService (Qt)
        |                    |                    |
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             |
                    PathUtilsStd (C++17)

================================================================================
                        COMPONENT RELATIONSHIPS
================================================================================

DictionaryManagerStd:
  â”œâ”€> Loads dictionaries by file extension
  â”œâ”€> Creates parser (one of: Json, StarDict, Mdict, Dsl, Csv)
  â”œâ”€> Maintains IndexEngineStd for search
  â””â”€> Supports: exact, prefix, fuzzy, wildcard, regex search

IndexEngineStd:
  â”œâ”€> Trie for prefix search (O(k) complexity)
  â”œâ”€> HashMap for word normalization
  â”œâ”€> Tracks which dictionary each word belongs to
  â””â”€> Supports persistence (save/load index)

DataStoreStd:
  â”œâ”€> Manages search history (JSON array)
  â”œâ”€> Manages vocabulary (JSON array of objects)
  â”œâ”€> Tolerant JSON parser (handles malformed input)
  â””â”€> Exports vocabulary to CSV

PathUtilsStd:
  â”œâ”€> Directory management (data_dir, cache_dir)
  â”œâ”€> Cache pruning by size and age
  â””â”€> Configurable via environment variables

================================================================================
                          FILE FORMAT SUPPORT
================================================================================

COMPLETE (âœ…):
  - JSON Dictionary Format
    {
      "name": "Dictionary Name",
      "description": "...",
      "entries": [
        {"word": "...", "definition": "..."},
        ...
      ]
    }

  - StarDict Format (uncompressed)
    â”œâ”€> .ifo (header file with metadata)
    â”œâ”€> .idx (binary index: word + offset + size)
    â””â”€> .dict (uncompressed definitions)
        Supports: 32-bit and 64-bit offset modes

  - DSL Format (ABBYY Lingvo)
    â”œâ”€> Text-based with markup
    â”œâ”€> Headers: #NAME, #DESCRIPTION, #ENCODING, etc.
    â””â”€> Entries: headword + definition

  - CSV/TSV Format
    â”œâ”€> Auto-detects separator (Tab > Comma > Semicolon)
    â”œâ”€> Format: word<sep>definition
    â””â”€> Supports comments and quoted fields

PARTIAL (âš ï¸):
  - MDict Format
    â”œâ”€> SIMPLEKV: âœ… Full support
    â”œâ”€> KIDX/RDEF: âš ï¸ Decompression exists, record parsing incomplete
    â”œâ”€> KBIX/KBIX2: ðŸš« Stub only
    â””â”€> KEYB/RDEF: ðŸš« Stub only

NOT IMPLEMENTED (ðŸš«):
  - StarDict Compression (.dict.dz with gzip)
  - MDict Encryption/Decryption

================================================================================
                          SEARCH CAPABILITIES
================================================================================

Supported Search Types (via IndexEngineStd):
  1. Exact Match
     - Direct hash table lookup with normalization
     - O(log n) complexity

  2. Prefix Search
     - Trie-based traversal
     - Returns all words starting with prefix
     - O(k + m) where k = prefix length, m = results

  3. Fuzzy Search
     - Levenshtein distance (edit distance)
     - Returns words within specified edit distance
     - O(n * m) where n = word length, m = dictionary size

  4. Wildcard Search
     - Pattern matching with * (any chars) and ? (single char)
     - Custom matching algorithm

  5. Regex Search
     - Full regular expression support via <regex>
     - Uses std::regex for matching

================================================================================
                        BUILD CONFIGURATION
================================================================================

CMake Variables:
  - UNIDICT_BUILD_QT_CORE
    â”œâ”€> When ON: Builds Qt wrapper layer
    â”œâ”€> When OFF: Skips Qt wrappers
    â””â”€> Default: ON

Libraries Generated:
  1. unidict_std_core (always built)
     â”œâ”€> PathUtilsStd
     â”œâ”€> DataStoreStd
     â”œâ”€> IndexEngineStd
     â”œâ”€> DictionaryManagerStd
     â””â”€> All parsers (Json, StarDict, Mdict, Dsl, Csv)

  2. unidict_core (only if UNIDICT_BUILD_QT_CORE=ON)
     â”œâ”€> Qt wrappers (IndexEngine, DataStore, DictionaryManager)
     â”œâ”€> Qt parsers (Json, StarDict, Mdict)
     â”œâ”€> PluginManager
     â”œâ”€> LookupService
     â””â”€> PathUtils
     
  3. Dependencies:
     â”œâ”€> ZLIB (for decompression)
     â”œâ”€> Qt6::Core (for Qt layer only)
     â””â”€> C++17 standard library (for std layer)

================================================================================
                        DESIGN PATTERNS USED
================================================================================

1. DUAL-LAYER ARCHITECTURE
   - Qt layer delegates to std layer via adapters
   - Enables Qt-independence while maintaining backward compatibility
   - Allows incremental migration to std-only core

2. ONE-OF UNION PATTERN
   - DictionaryManagerStd::Holder contains exactly one parser
   - Reduces memory overhead and simplifies dispatch

3. TRIE + HASHMAP HYBRID
   - Trie: Fast prefix search O(k)
   - HashMap: Fast exact match and normalization O(log n)
   - Best of both worlds for search efficiency

4. TOLERANT PARSER PATTERN
   - Parsers handle malformed input gracefully
   - JSON parser: section-based, not strict
   - CSV: auto-detects separator
   - Increases robustness and usability

5. PLUGIN ARCHITECTURE
   - PluginManager supports dynamic parser registration
   - Enables runtime extensibility
   - Multiple parsers per extension (tries in order)

6. SINGLETON PATTERN
   - DictionaryManager & DataStore use singleton
   - Ensures single instance across application
   - Qt-based implementations maintain backward compatibility

================================================================================
                        TEST COVERAGE SUMMARY
================================================================================

Total Test Files: 26

Std Core Tests (23 files):
  â”œâ”€> index_engine_std_test.cpp        âœ… Trie and search
  â”œâ”€> data_store_std_test.cpp          âœ… JSON persistence
  â”œâ”€> dictionary_manager_std_test.cpp  âœ… Multi-format loading
  â”œâ”€> json_parser_std_test.cpp         âœ… JSON parsing
  â”œâ”€> stardict_std_test.cpp            âœ… StarDict format
  â”œâ”€> dsl_parser_std_test.cpp          âœ… DSL format
  â”œâ”€> cache_prune_std_test.cpp         âœ… Cache management
  â”œâ”€> index_persistence_std_test.cpp   âœ… Index I/O
  â”‚
  â”œâ”€> MDict Variants (8 files):
  â”‚   â”œâ”€> mdict_simplekv_std_test.cpp         âœ…
  â”‚   â”œâ”€> mdict_kidx_std_test.cpp             âš ï¸
  â”‚   â”œâ”€> mdict_kbix_std_test.cpp             âš ï¸
  â”‚   â”œâ”€> mdict_keyb_std_test.cpp             âš ï¸
  â”‚   â”œâ”€> mdict_utf16_header_std_test.cpp     âš ï¸
  â”‚   â”œâ”€> mdict_zlib_std_test.cpp             âš ï¸
  â”‚   â”œâ”€> mdict_realheur_std_test.cpp         âš ï¸
  â”‚   â””â”€> mdict_mdxkr_std_test.cpp            âš ï¸
  â”‚
  â””â”€> dsl_parser_csv_test.cpp           âœ… CSV variant

Qt Core Tests (3 files):
  â”œâ”€> index_engine_test.cpp
  â”œâ”€> data_store_test.cpp
  â””â”€> lookup_service_test.cpp

================================================================================
